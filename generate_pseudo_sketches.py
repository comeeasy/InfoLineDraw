import yaml
import cv2

import os
import argparse

from pathlib import Path
from PIL import Image
from glob import glob

from util.pseudo_sketches_webui_runner import WebuiAPI
from util.util import read_bmp_np

from tqdm import tqdm

from multiprocessing import Pool


def main(args):
    # Open the file and load its contents
    with open(args.input_txt, 'r') as file:
        nouns = list(map(lambda x: x.strip(), file.readlines()))
        nouns = [noun for noun in nouns if noun != ''] # 줄바꿈 문자 들어갈 시 제거
    
    # Initiate webui runner to run Stable Diffusion
    if args.txt2sktch or args.vec2img:
        api = WebuiAPI(args.url)    
    else:
        api = None
    
    bmp_sketches_filename = lambda noun_for_c, i: f"{noun_for_c}_{i}.bmp"
    for noun in tqdm(nouns):
        try:
            # noun name for FDoG
            noun_for_c = noun.replace(" ", "_")
            # # Generate image
            txt2sketch(args, api, noun, noun_for_c, bmp_sketches_filename)

            # For generated images do..
            vectorize_gray_sketch(args, noun_for_c, exist_ok=True)
                
            # # Generate image using ControlNet with sketch
            vec2img(args, api, noun_for_c, noun)
        except KeyboardInterrupt:
            exit(0)
        except:
           with open("error_nouns.txt", "a+") as f:
               f.write(f"{noun}\n")

def vec2img(args, api, noun_for_c, noun):
    # Generate image using ControlNet with sketch
    # Assume every images are exist, if first image does exit. e.g. bus_0_0_img.png
    
    img_from_vec_filename = lambda noun_for_c, i: f"{noun_for_c}_{i}_img.png"
    vec_sketch_paths = os.path.join(args.output_dir_vec_basedir, f"{noun_for_c}_*_shifted.bmp")
    
    if not args.vec2img:
        return
    
    if len(glob(vec_sketch_paths)) == 0:
        raise FileNotFoundError("There is no vec sketches to convert real image")
        
    for i in range(len(glob(vec_sketch_paths))):
        img_from_sketch_path = os.path.join(args.output_dir_img_basedir, img_from_vec_filename(noun_for_c, i))
        
        if not Path(img_from_sketch_path).exists():
            print(f"Generating real image of {noun} vec-sketch ...", end=" ")
            vec_sketch = Image.fromarray(read_bmp_np(os.path.join(args.output_dir_vec_basedir, f"{noun_for_c}_{i}_shifted.bmp")))
            sketch_to_imgs = api.generate_image(
                prompt=noun, 
                steps=7, cfg_scale=2, width=1024, height=1024, 
                batch_size=1, sketch=vec_sketch
            )
            # Save results of ControlNet
            print(f"{img_from_sketch_path} is saved.")
            cv2.imwrite(img_from_sketch_path, sketch_to_imgs[0])
            print("Done.")
        else:
            print(f"Images of {noun} generated by sketch is already exist. {img_from_sketch_path}")

def txt2sketch(args, api, noun, noun_for_c, bmp_sketches_filename):
    # Generate image
    # Assume every images are exist, if first image does exit. e.g. bus_0.png
    bmp_sketches_first_filename = os.path.join(args.output_dir_sketch_basedir, f"{noun_for_c}_0.bmp")
    bmp_sketches_filename_pattern = os.path.join(args.output_dir_sketch_basedir, f"{noun_for_c}_*.bmp")
    
    if not args.txt2sktch:
        return 
    # Check only first sketch file
    if not Path(bmp_sketches_first_filename).exists():
        print(f"Generating sketch of {noun}...", end=" ")
        imgs = api.generate_image(
            prompt=noun, 
            steps=7, cfg_scale=2, width=1024, height=1024, 
            batch_size=args.sketch_batch_size, seed=args.seed)
        
        # convert sketch to 3-channel GRAY scale image
        gray_sketches = (cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) for img in imgs)
        gray_3c_sketches = (cv2.cvtColor(gray_sktch, cv2.COLOR_GRAY2RGB) for gray_sktch in gray_sketches)
        
        # If there is no sketches, save gray_3c_sketch images
        for i, gray_3c_sketch in enumerate(gray_3c_sketches):
            bmp_sketch_path = os.path.join(args.output_dir_sketch_basedir, bmp_sketches_filename(noun_for_c, i))
            if not Path(bmp_sketch_path).exists():
                cv2.imwrite(bmp_sketch_path, gray_3c_sketch)
        print("Done.")
    else:
        print(f"Sketches of {noun} are exist. Load existing sketches. {bmp_sketches_first_filename}")

def vectorize_gray_sketch(args, noun_for_c, exist_ok=True):
    # vectorized_sketch_filename = lambda noun_for_c, i: f"{noun_for_c}_{i}_shifted.bmp"
    
    if not args.sktch2vec:
        return
    else:
        num_of_sketches = len(glob(os.path.join(args.output_dir_sketch_basedir, f"{noun_for_c}_*.bmp")))
        if num_of_sketches == 0:
            raise FileNotFoundError("There is no sketches to vectorize")
        
        for i in range(num_of_sketches):
            sketch_path = os.path.join(args.output_dir_sketch_basedir, f"{noun_for_c}_{i}.bmp")
            path_to_vecsktch_automatically_saved = os.path.join(args.output_dir_sketch_basedir, f"{noun_for_c}_{i}_shifted.bmp")
            vectorized_sketch_path = os.path.join(args.output_dir_vec_basedir, f"{noun_for_c}_{i}_shifted.bmp")

            if not exist_ok or not Path(vectorized_sketch_path).exists():
                
                # If does rsc_dir exist, it means that there is a process converting sketch to vec-sketch
                rsc_path = os.path.join(args.output_dir_sketch_basedir, f"{noun_for_c}_{i}_rsc")
                if Path(rsc_path).exists():
                    continue
                
                # vectorize generated sketch
                # it save <sketch_path>.bmp -> <sketch_path>_shifted.bmp
                os.system(f"./FDoG_GUI \"{sketch_path}\" 1> FDoG.log 2> FDoG.error")
                
                # Raise runtimeerror in FDoG.
                if not Path(path_to_vecsktch_automatically_saved).exists():
                    raise RuntimeError(f"FDoG Error: {path_to_vecsktch_automatically_saved} not exist.")
            
                os.system(f"mv {path_to_vecsktch_automatically_saved} {vectorized_sketch_path}")
            else:
                print(f"vec-Sketches of {noun_for_c} are exist. Load existing sketches. {vectorized_sketch_path}")
            
            
    os.system(f"rm -rf {os.path.join(args.output_dir_sketch_basedir, f'{noun_for_c}_*_rsc')}")
    



if __name__ == "__main__":
    # Create the parser
    parser = argparse.ArgumentParser(description='Generate pseudo sketch-image dataset.')

    # Add arguments
    parser.add_argument("--input_txt", type=str, default="nouns_to_generate.txt")
    parser.add_argument("--output_dir", type=str, default="pseudo_img_sketch_dataset", 
                            help="Spedify directory path to save results")
    parser.add_argument('--sketch_batch_size', type=int, default=1, help='sketch batch size')
    parser.add_argument('--seed', type=int, default=-1)
    parser.add_argument('--url', type=str, default="http://127.0.0.1:7860", help="url for running webui of AUTOMATIC1111")
    parser.add_argument('--txt2sktch', action='store_true')
    parser.add_argument('--sktch2vec', action='store_true')
    parser.add_argument('--vec2img', action='store_true')

    # Parse the arguments
    args = parser.parse_args()

    # create directories
    args.output_dir_sketch_basedir = os.path.join(args.output_dir, "sketches")
    args.output_dir_img_basedir = os.path.join(args.output_dir, "imgs")
    args.output_dir_depth_basedir = os.path.join(args.output_dir, "depths")
    args.output_dir_vec_basedir = os.path.join(args.output_dir, "vecsktch")
    Path(args.output_dir_sketch_basedir).mkdir(parents=True, exist_ok=True)
    Path(args.output_dir_img_basedir).mkdir(parents=True, exist_ok=True)
    Path(args.output_dir_depth_basedir).mkdir(parents=True, exist_ok=True)
    Path(args.output_dir_vec_basedir).mkdir(parents=True, exist_ok=True)

    # Set absolute path for paths
    args.output_dir = os.path.abspath(args.output_dir)

    # Now you can use the arguments as variables in your program
    print(f"input_txt: {args.input_txt}")
    print(f"output_dir: {args.output_dir}")
    print(f"sketch_batch_size: {args.sketch_batch_size}")
    print(f"seed: {args.seed}")
    print(f"url: {args.url}")
    print(f"txt2sktch: {args.txt2sktch}")
    print(f"sktch2vec: {args.sktch2vec}")
    print(f"vec2img: {args.vec2img}")
    
    main(args)
    